# アンチパターン API 設計方針（やさしく説明版）

この Go API は「こういう作りにすると大変なことになるよ」という反面教師として作っています。画面や API の表側（入出力の形式）は TypeSpec でちゃんと定義していますが、中身はあえて混乱しやすい構造にして、「なぜ設計が大事なのか」を体感できるようにしています。

---

## 全体の考え方

- API の仕様（URL やリクエスト・レスポンスの型）は TypeSpec で定義しておく。
- でもサーバー内部は Go 1 プロジェクトで完結させ、あえてベストプラクティスに反する作りにする。
- フロントエンド（Next.js）からは HTTP でこの Go API を呼び出す。
- 使用技術:
  - Echo（Web フレームワーク）
  - sqlc（SQL -> Go コード生成）
  - golang-migrate（DB マイグレーション）
- 目的は「見た目は普通だけど中身はスパゲッティ」という状態を再現し、後でクリーンアーキテクチャ版と比較できるようにすること。

---

## やっているアンチパターン一覧

| # | やっていること | なぜ良くないか |
|---|----------------|----------------|
| 1 | ドメイン層を用意せず、TypeSpec 生成の型と sqlc の型を直接やりとり | テーブルや API を変えると全層に影響し、ビジネスルールの居場所がなくなる |
| 2 | Controller を薄くし過ぎて、Service が全部抱え込む | 入力チェック、SQL、ロギングなどごちゃ混ぜで巨大関数が誕生 |
| 3 | Repository interface を作らず、sqlc を直呼び | テストや差し替えが行いづらい |
| 4 | ユースケース粒度のメソッドがなく、if 文で分岐 | 仕様追加のたびに if 文が増え、読めないコードになる |
| 5 | ビジネスルールがファイル内に点在 | 「何を守らないといけない？」をコード全文検索しないと分からない |
| 6 | トランザクション制御を各 Service が手書き | Begin/Commit のコピペ地獄。境界もバラバラ |
| 7 | エラーの整形だけきれいにして、中身は雑 | 表面上は統一された JSON でも、エラー分類が意味不明 |
| 8 | Logger や Config を直接 Service で参照 | 依存が散らばり、テストも困難 |
| 9 | TypeSpec の契約をインターフェース化していない | 未実装のエンドポイントがあってもコンパイルで気づけない |

---

## ディレクトリ構成イメージ

```
backend/
├─ cmd/api/main.go          # Echoを起動するエントリーポイント
├─ internal/
│  ├─ controller/           # ルーティングとレスポンスを持つ層
│  ├─ service/              # 神オブジェクト化するビジネスロジック
│  ├─ db/                   # sqlc用のクエリやプールなど
│  └─ generated/            # TypeSpec / sqlc 生成コード
└─ migrations/              # golang-migrate用SQL
```

---

## 運用ルール

1. **表側（API 契約）は崩さない**  
   TypeSpec で決めた入出力は守る。ただし中身はごちゃごちゃ。

2. **内部はあえて崩す**  
   上記のアンチパターンを忠実に実装し、何が辛いかを体験できるようにする。

3. **比較教材として使う**  
   もう一つのリポジトリでクリーンアーキ版を作り、違いを説明できるようにする。

---

この方針を守って開発していくと、「仕様は守っているのに保守が辛い API」が出来上がります。ここから「どうやって改善していくのか」を学ぶのがこの教材の狙いです。***
